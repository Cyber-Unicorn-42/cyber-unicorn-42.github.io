---
layout: post
read_time: true
show_date: true
title:  One to rule them all
date:   2022-07-23 10:00:00 +1000
description: My suggestions on how to manage credentials, certificates and secrets.
img: posts/2022-07-23-cred-cert-secret-mgmt/hero.jpg
tags: [security,non-technical]
author: Peter Dodemont
---
These days users have lots of accounts for various different services or applications they require for their day to day tasks. Beyond those, the IT team usually have even more, usually sensitive, items to track as they have various certificates or keys for the different services that are setup or need to be connected to. In this article I will go through how I think they can be managed in a way that is secure, but also not overly cumbersome.

## Credential Management
When talking about credential management, there are 2 sets of guidelines I follow. The first set applies to everyone, the second set is some additional guidelines for a group of privileged users.  
I'll start with the recommendations for the privileged users. In this context, this is a group of users that has the ability to add other users to a system or that has far reaching access across the entire system (e.g. being able to delete all data). Usually this group consists of IT team members, but it can also include users from other business units if some of the management tasks have been handed over to them.  
The very first thing to do is to make sure that these users have different accounts for their normal day to day work and for when they need to perform privileged actions. These accounts should also not be easily discoverable (e.g. by having usernames with "admin" in them or by having a description that states it's an admin account).  
Next these users should be using a password manager to store randomly generated passwords for those privileged accounts. I won't go into details on password managers here, as I have written about them [before](password-manager.html). Password managers also allow you to securely share credentials on those occasions where it is not possible to have separate credentials for each different user.  
Now let's look at what I use as guidelines for everyone. You might have thought that a password manager would be what I recommend as the solution for credential management across the board, but I have found that there can be considerable friction when using password managers, especially when using desktop apps. In addition there is also a requirement to train users on how to use a password manager to it's fullest effect, as the biggest benefit, from a security perspective, will be achieved if users use randomly generated passwords and not just use the password manager as a store for passwords they thought of themselves. Then there is also the fact that you rely on the user doing the right thing by using the password manager every time, and not reusing passwords.  
Instead my preferred method of credential management for all users is using single sign on (SSO). With SSO users only have to remember a single set of account details, and then can use that to sign in to all services and applications (including the password manager). You might think that goes against what I have stated in other articles, or it might even go against current recommendations, but that is not the case. With SSO you don't register with the same username and password on every service, you instead direct the service to pass the authentication of the user back to a central identity management platform (e.g. Azure Active Directory or Okta). This identity management platform then does the authentication of the user and passes a response back to the service that says if it was successful and who the user is. This model does mean that the identity platform becomes a central source, but it is a lot easier to put strong controls on a single platform that is designed for that purpose rather than trying to manage this across a large number of different services and applications where it is not the main focus. I won't cover all the controls you can put in place on identity platforms, as there are many and these will differ between platforms. I recommend that your read my articles on [password policies](\password-policies.html) and [multi-factor authentication](\mfa.html) as these are 2 controls that will be available across all available platforms and are hugely impactful from a security perspective.  
There are still many applications and services that don't support SSO unfortunately, and for those you will still need to use a password manager. But by setting up SSO for as many services and applications as possible you limit the ability for users to have credential on each of these and remove the risk of compromising those, likely reused, credentials if that service where to be compromised. As mentioned before, with a password manager you also rely on the users to do the right thing, where as with SSO you give them no option but to do the right thing.

## Certificate Management
Certificate management encompasses a number of different aspects and not all aspects are going to work in every scenario that you might use a certificate in. So rather than approaching this from a set of recommendations, I will approach it from a number of different scenarios, followed by some general comments.  
The first scenario I want to cover is probably the most common one, certificates used to encrypt data transfers (e.g. certificates used for HTTPS, like on this website). These type of certificates usually get accessed through a single name. Generally this means the certificate lives on a single "server" (could also be a load balancer or other device). For these type of certificates I recommend using short lived, auto renewing certificates that have a single specific subject name in the certificate.  
The reason for these being short lived is that these certificates are on systems that are usually exposed to the internet and thus are at greater risk of being compromised by way of vulnerabilities in the systems they are running on. You might say, but I can just revoke a certificate that was compromised, and you are right in that you can do this, but revocation is fundamentally broken (see [here])(https://scotthelme.co.uk/revocation-is-broken/) and [here](https://scotthelme.co.uk/revocation-checking-is-pointless/). By having it short lived even if it is stolen it won't be of use for long.  
The reason for having a single subject name is similar to the previous point in that it means that it can only be used to impersonate a single name rather than a wide variety of different ones.  
And finally it should be auto-renewing so that you don't have any management overhead from having single use certificates once it has been setup. The process just takes care of the renewal rather than you having to manually go through it every few weeks of months.  
While traditionally these certificates used to cost money, these days there are several free certificate authorities (CA) out there you can use [Let's Encrypt](https://letsencrypt.org/), [ZeroSSL](https://zerossl.com/), [Buypass](https://www.buypass.com/products/tls-ssl-certificates) or [SSL.com](https://www.ssl.com/how-to/order-free-90-day-ssl-tls-certificates-with-acme/). And these CAs also all have a way of automating the renewal process as recommended in the previous point.  
The next scenario I want to cover is similar to the first, but this time the "server" runs several applications and thus is being accessed through several different names. Sometimes it's possible to have a different certificate for each service, and if that is the case I recommend doing it, but it isn't always possible. In those cases you can use a certificates that has multiple names on it. Other than having multiple names the rest of the certificate should be the same as in the previous scenario, it should be short lived and auto renewing. The CAs that offer certificates for the first service normally also so do so for this second type. All the same benefits from the first type apply to this one as well, with the obvious difference that a stolen certificate can be used to impersonate several servers (but still not just any server).  
A third scenario, is where there is a certificate that is used to sign an application or script so that it's origin can be validated. These types of certificates are called code signing certificates and they can not be obtained for free. So in this situation getting short lived certificates is generally not going to be possible as it would become too expensive. These certificates have stricter rules around them and also normally will only have a single subject name. So the recommendations from the previous scenarios don't really apply to them as they don't work in the same way. For this type of certificate I recommend storing them in a certificate management service once they have been acquired. This is similar to a password manager, but has additional features specifically for certificates (e.g. notification of expiry or ability to renew automatically). Most cloud services offer this type of service (e.g. [Azure](https://azure.microsoft.com/en-au/services/key-vault/#product-overview), [AWS](https://aws.amazon.com/certificate-manager/), [Google Cloud](https://cloud.google.com/certificate-manager/docs/overview)).  
By storing the certificates in one of these services you get the ability to limit who has access to them and the keep a log of who has accessed them as well (as long as you have enabled logging on the service in question). This is very important with code signing certificates as these can be used to distribute software as the subject of the certificate, so these need to be guarded closely and access should be very limited.
Those are the three most common scenarios for certificates I have come across. There are others, but they don't pop up often and I can generally apply the recommendations from one of those 3 scenarios to any other scenario using a common sense approach.  
One type of certificate I have not mentioned and I come across a lot is the wildcard certificate. The reason I haven't mentioned it in any of the scenarios is because I don't recommend using this type of certificate. The wildcard used to be very popular before you could get free certificates as it was a single certificate you could use on every single server that needed a certificate, even future ones. The biggest risk with wildcard certificates is that if compromised someone can use it to impersonate anything on the domain of the certificate, so they could set servers up outside of the environment and use the certificate to make it appear legitimate. There probably are scenarios where a wildcard is the right option, but those are few and far between, and I haven't come across one yet.  
Now that we have covered the scenarios, 2 other crucial part of certificate management is keeping track of where each certificate has been used and the expiry. If you are not using wildcard certificates, it is a fairly straight forward process, as each certificate will provide the details of where it is being used and when it expires. If you are using wildcard certificates you will need to manually keep track of it. This can be done in whatever way works for you e.g. a spreadsheet, but it's yet another reason to try and avoid using them. It also require the discipline to update the tracking information every time the certificate is used somewhere, I have never seen this done successfully manually.  
Another option is to track certificates with a monitoring tool, this usually works better but still requires some discipline to add it to the monitoring tool when it is used somewhere new. But the monitoring tools won't cover code signing certificates as those are not accessible.  
Certificate management services usually provide the ability to track and notify on expiry, but lack a way to track where the certificate might be used. So you might end up with a combination of methods.

## Secret Management
 In some way secrets are similar to credentials. But rather than come in a pair (i.e. username and password), they can be a single item (e.g. SQL connection strings, license keys, ...) or a pair (e.g. cryptographic keys). This similarity means that you could use a password manager to store these, and that does work fairly well and has all the benefits from using a password manager, but you usually end up having to fill in a number of fields with useless data. A drawback of most (if not all) password managers, is that they don't have a way for accessing these secrets programmatically from within an application. This can be very useful for things like SQL connection strings so they are not at risk of being exposed in the source code.  
 Another option is to use a key management services as offered by most cloud services (e.g. [Azure](https://azure.microsoft.com/en-au/services/key-vault/#product-overview), [AWS](https://docs.aws.amazon.com/kms/latest/developerguide/overview.html), [Google Cloud](https://cloud.google.com/security-key-management)). This offers similar benefits to the certificate management services, like granular access control and audit trials. They also normally offer programmatic access. This means that secrets don't need to be hard coded in an application or config file but can be retrieved from these vaults as needed instead. This reduces the risk of exposing these credentials to users that don't need to know them, and also makes updating them a lot easier as it can just be done from a single location rather than having to go through each server or find each instance in the source code.  
 
 I hope this article has given you an understanding of how you can do credential, certificate and secret management in a secure but also manageable way. As always, if you have any questions or comments, please reach out